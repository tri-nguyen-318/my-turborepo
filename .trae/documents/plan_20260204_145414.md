# Implement Real-Time Leaderboard with Microservices (Redis + Socket.io)

## 1. Infrastructure Setup
- **Redis**: Add Redis service to `docker-compose.yml` for high-performance leaderboard storage (Sorted Sets).
- **Environment**: Update `.env` files with Redis connection details.

## 2. Microservice Architecture Implementation
- **New Service**: Create `apps/leaderboard` as a standalone NestJS microservice.
  - **Responsibilities**: Manage scores, handle ranking logic, persist data in Redis.
  - **Transport**: Use RabbitMQ (already available) for asynchronous communication with the Gateway.
  - **Data Layer**: Use `ioredis` to implement `ZADD`, `ZINCRBY`, `ZREVRANGE` for efficient ranking.
- **API Gateway (Refactor `apps/backend`)**:
  - Treat the existing `apps/backend` as the **API Gateway** (BFF).
  - **Proxy**: Forward HTTP requests (e.g., `GET /leaderboard`) to the Leaderboard Service.
  - **Real-Time Bridge**: Listen for `leaderboard-update` events from RabbitMQ and broadcast them to frontend clients via Socket.io.

## 3. Implementation Steps
1.  **Scaffold Leaderboard Service**: Initialize `apps/leaderboard` with NestJS.
2.  **Redis Integration**: Implement `LeaderboardRepository` in the new service using `ioredis`.
3.  **Messaging**:
    - `Gateway` -> `Leaderboard`: "Submit Score" (Command)
    - `Leaderboard` -> `Gateway`: "Leaderboard Updated" (Event)
4.  **Socket.io**: Update `ChatGateway` (or create `LeaderboardGateway`) in `backend` to handle client subscriptions and broadcast updates.

## 4. Frontend Implementation
- **Component**: Create `Leaderboard` component.
- **Integration**:
  - Fetch initial state via HTTP (Gateway -> Leaderboard).
  - Listen for `leaderboardUpdate` socket events.
- **UI**: Display rankings using the Shadcn Table component.

## 5. Verification
- Validate Redis connection.
- Verify RabbitMQ message passing between Gateway and Leaderboard Service.
- Verify real-time UI updates on score changes.